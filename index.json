[{"content":"概念 像是選擇不同交通方式上班， 把影響選擇的因素(例如: 天候、預算、身體狀況、緊急程度等)和選擇帶來的後果(例如: 路線、耗時、花費等)拆分開來管理。\n圖片來源: https://refactoring.guru/design-patterns/strategy  這篇來自讀過 Design Patterns Explained: A New Perspective on Object Oriented Design, 2nd Edition 一書中 The Strategy Pattern 章節的重點整理。\n作者提出一系列面對新需求的應對方式使系統程式碼更具彈性，在面對未來的變化能更從容、更易擴充和維護。\n 處理新需求之案例研究 書中以一個在美國的國際電商為實務案例來說明在面對新需求的思考和處理方式。\n訂單處理系統之系統架構 TaskController\n 處理銷售請求 決定何時將請求交給 SalesOrder 來處理訂單  SalesOrder\n 透過 GUI 填寫訂單 處理稅額計算 \u0026lt;\u0026ndash; 本章討論案例 列印收據    新需求：支援加拿大的稅額計算\n 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23  // Handle Tax switch (myNation) { case US: // US Tax rules here break;  case Canada: // Canadian Tax rules here break; } // Handle Currency switch (myNation) { case US: // US Currency rules here break;  case Canada: // Canadian Currency rules here break; } // Handle Date Format switch (myNation) { case US: // use mm/dd/yy format break;  case Canada: // use dd/mm/yy format break; }     新需求：支援德國的稅額計算＆多國語系\n 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37  // Handle Tax switch (myNation) { case US: // US Tax rules here break;  case Canada: // Canadian Tax rules here break;  case Germany: // Germany Tax rules here break; } // Handle Currency switch (myNation) { case US: // US Currency rules here break;  case Canada: // Canadian Currency rules here break;  case Germany: // Euro Currency rules here break; } // Handle Date Format switch (myNation) { case US: // use mm/dd/yy format break;  case Canada: case Germany: // use dd/mm/yy format break; } // Handle Language switch (myNation) { case US: case Canada: // use English break;  case Germany: // use German break; }     新需求：支援加拿大魁北克的法語\n 1 2 3 4 5 6 7 8 9 10 11  // Handle Language switch (myNation) { case Canada: if (inQuebec) { // use French break;  } case US: // use English break;  case Germany: // use German break; }    以上作法開發中不少見，很直覺新增條件式來應付需求變化\n隨著時間過去，條件式可能因為需求的堆疊而產生多種組合像棵樹一樣蔓延\n這些條件全都集中在 SalesOrder 裡，程式碼會越來越難以維護\n作者也把這種現象稱作 switch creep\n 這時熟悉物件導向特性的開發者可能會想，如果改用繼承來小幅度修改呢？\n沒錯，接下來介紹透過物件導向“直接繼承”的方式來處理新需求\n揭露了另一種混沌的開端\n  直接繼承並覆寫特定方法\n 讓加拿大訂單和德國訂單繼承美國訂單，並 override 稅額計算方法\n效果看起來還不錯，將不同國家的稅額計算規則獨立封裝起來，互不干擾\n但這種類別直接繼承的擴充方式容易產生過多的類別\n例如：未來要支援“免運訂單”、“員購訂單”的稅額計算，則類別數會快速增加\n光是支援兩個國家的稅額計算就需要增加這麼多類別\n而且別忘了 SalesOrder 除了稅額計算還有另外兩個功能，這兩個功能未來如果有其他多型分支，類別數勢必爆炸式增長！\n上述這樣的現象也稱作「組合爆炸(Combinatorial explosion)」\n 組合爆炸原因是類別的責任未妥善劃分\n 當每個類別擁有太多責任時 當每個責任需要多型分支時    這樣的情境就很適合本篇主角 Strategy pattern 登場啦！\n The Strategy Pattern  Find what varies and encapsulate it.\n找出變化並封裝之。\n 先將“稅額計算概念”從 SalesOrder 抽離，並抽象化成 abstract class\n再將每個國家的稅額計算細節各自封裝到 concreate class (USTax, CanTax)\n也就是說，未來出現稅額計算相關的需求變動，SalesOrder 不用更改程式碼，只需要新增稅額計算類別就可以完成，這也符合了 SOLID 原則中的 OCP 開放封閉原則\n  Use aggregation instead of inheritance.\n使用聚合代替繼承。\n 由 TaskController 選擇具體稅額計算物件(USTax, CanTax)\n將具體稅額計算的 物件參照(reference) 傳遞給 SalesOrder\nSalesOrder 透過抽象稅額計算(CalcTax) 參照到具體稅額計算物件，並執行具體稅額計算物件，而且並不會知道具體執行了哪個物件\n 定義  Define a family of algorithms, encapsulate each one, and make them interchangeable. Strategy lets the algorithm vary independently from clients that use it. \u0026mdash; Gamma, et al\n 通用結構圖 References  https://refactoring.guru/design-patterns/strategy https://www.youtube.com/watch?v=IkG_KuMpQRM  ","permalink":"https://benny-sun.github.io/post/design-pattern/strategy/","summary":"概念 像是選擇不同交通方式上班， 把影響選擇的因素(例如: 天候、預算、身體狀況、緊急程度等)和選擇帶來的後果(例如: 路線、耗時、花費等)拆分開來管理。\n圖片來源: https://refactoring.guru/design-patterns/strategy  這篇來自讀過 Design Patterns Explained: A New Perspective on Object Oriented Design, 2nd Edition 一書中 The Strategy Pattern 章節的重點整理。\n作者提出一系列面對新需求的應對方式使系統程式碼更具彈性，在面對未來的變化能更從容、更易擴充和維護。\n 處理新需求之案例研究 書中以一個在美國的國際電商為實務案例來說明在面對新需求的思考和處理方式。\n訂單處理系統之系統架構 TaskController\n 處理銷售請求 決定何時將請求交給 SalesOrder 來處理訂單  SalesOrder\n 透過 GUI 填寫訂單 處理稅額計算 \u0026lt;\u0026ndash; 本章討論案例 列印收據    新需求：支援加拿大的稅額計算\n 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23  // Handle Tax switch (myNation) { case US: // US Tax rules here break;  case Canada: // Canadian Tax rules here break; } // Handle Currency switch (myNation) { case US: // US Currency rules here break;  case Canada: // Canadian Currency rules here break; } // Handle Date Format switch (myNation) { case US: // use mm/dd/yy format break;  case Canada: // use dd/mm/yy format break; }     新需求：支援德國的稅額計算＆多國語系","title":"Strategy pattern"},{"content":" 合併排序，屬於穩定排序。\n把數列從中間拆分成兩段，直到不能再分，將拆分的元素兩兩比對後再合併起來，達到排序效果。\n Time \u0026amp; Space complexity    Case Time complexity Space complexity     Best O(nlogn) O(1)   Average O(nlogn) O(1)   Worst O(nlogn) O(1)    實作 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49  /** * 主程式 * 定義數列要排序的開頭及結尾 */ function mergeSort(array $nums) { $front = 0; $end = count($nums) - 1; MSort($nums, $front, $end); return $nums; } /** * 遞迴將數列兩半拆分 */ function MSort(array \u0026amp;$nums, $front, $end) { if ($front \u0026lt; $end) { $mid = intval(($front + $end) / 2); MSort($nums, $front, $mid); // 拆分左半邊的數列  MSort($nums, $mid + 1, $end); // 拆分右半邊的數列  merge($nums, $front, $mid, $end); } } /** * 將左右兩邊的數列比大小後再合併 */ function merge(array \u0026amp;$nums, $front, $mid, $end) { $len = ($end - $front) / 2 + 1; $leftNums = array_slice($nums, $front, $len); $rightNums = array_slice($nums, $mid + 1, $len); $left[] = PHP_INT_MAX; $right[] = PHP_INT_MAX; $idxLeft = 0; $idxRight = 0; for ($i = $front; $i \u0026lt;= $end; $i++) { if ($leftNums[$idxLeft] \u0026lt; $rightNums[$idxRight]) { $nums[$i] = $leftNums[$idxLeft]; $idxLeft++; } else { $nums[$i] = $rightNums[$idxRight]; $idxRight++; } } }   Reference  示意圖  ","permalink":"https://benny-sun.github.io/post/2020/merge-sort/","summary":" 合併排序，屬於穩定排序。\n把數列從中間拆分成兩段，直到不能再分，將拆分的元素兩兩比對後再合併起來，達到排序效果。\n Time \u0026amp; Space complexity    Case Time complexity Space complexity     Best O(nlogn) O(1)   Average O(nlogn) O(1)   Worst O(nlogn) O(1)    實作 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49  /** * 主程式 * 定義數列要排序的開頭及結尾 */ function mergeSort(array $nums) { $front = 0; $end = count($nums) - 1; MSort($nums, $front, $end); return $nums; } /** * 遞迴將數列兩半拆分 */ function MSort(array \u0026amp;$nums, $front, $end) { if ($front \u0026lt; $end) { $mid = intval(($front + $end) / 2); MSort($nums, $front, $mid); // 拆分左半邊的數列  MSort($nums, $mid + 1, $end); // 拆分右半邊的數列  merge($nums, $front, $mid, $end); } } /** * 將左右兩邊的數列比大小後再合併 */ function merge(array \u0026amp;$nums, $front, $mid, $end) { $len = ($end - $front) / 2 + 1; $leftNums = array_slice($nums, $front, $len); $rightNums = array_slice($nums, $mid + 1, $len); $left[] = PHP_INT_MAX; $right[] = PHP_INT_MAX; $idxLeft = 0; $idxRight = 0; for ($i = $front; $i \u0026lt;= $end; $i++) { if ($leftNums[$idxLeft] \u0026lt; $rightNums[$idxRight]) { $nums[$i] = $leftNums[$idxLeft]; $idxLeft++; } else { $nums[$i] = $rightNums[$idxRight]; $idxRight++; } } }   Reference  示意圖  ","title":"Merge Sort"},{"content":" 又叫堆積排序，屬於穩定排序。 把陣列作為 binary tree 的資料結構，逐一把元素加入 heap 達到排序效果。\n Time \u0026amp; Space complexity    Case Time complexity Space complexity     Best O(nlogn) O(1)   Average O(nlogn) O(1)   Worst O(nlogn) O(1)    實作 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56  /** * 主函式 * 將數列由小到大排序 */ function heapSort(array $array) { buildMaxHeap($array); $length = count($array); for ($i = $length - 1; $i \u0026gt; 0; $i--) { swap($array[0], $array[$i]); maxHeapify($array, 0, $i); } return $array; } /** * 有 child 的節點進行 heapify * (因為堆排不考慮 leaf 節點之間的大小) */ function buildMaxHeap(array \u0026amp;$array) { $length = count($array); for ($i = $length / 2; $i \u0026gt;= 0; $i--) { maxHeapify($array, $i, $length); } } /** * 由上而下檢查 subtree，使 subtree 滿足 max heap 規則 * @param array $array 紀錄 heap * @param integer $root 當前 subtree 的根節點 index * @param integer $length 要處理的陣列長度，也是判斷child是否超出陣列長度 */ function maxHeapify(array \u0026amp;$array, int $root, int $length) { $left = 2 * $root + 1; $right = $left + 1; $largest = $root; // 紀錄「根、左、右」，最大值節點 index  if ($left \u0026lt; $length \u0026amp;\u0026amp; $array[$left] \u0026gt; $array[$root]) $largest = $left; if ($right \u0026lt; $length \u0026amp;\u0026amp; $array[$right] \u0026gt; $array[$largest]) $largest = $right; if ($root != $largest) { // 若根節點值不是三者中最大的  swap($array[$root], $array[$largest]); // 就與最大值節點調換  maxHeapify($array, $largest, $length); } } /** * 數值交換 */ function swap(\u0026amp;$a, \u0026amp;$b) { $tmp = $a; $a = $b; $b = $tmp; }   Reference  示意圖 演算法筆記  ","permalink":"https://benny-sun.github.io/post/2020/heapsort/","summary":"又叫堆積排序，屬於穩定排序。 把陣列作為 binary tree 的資料結構，逐一把元素加入 heap 達到排序效果。\n Time \u0026amp; Space complexity    Case Time complexity Space complexity     Best O(nlogn) O(1)   Average O(nlogn) O(1)   Worst O(nlogn) O(1)    實作 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56  /** * 主函式 * 將數列由小到大排序 */ function heapSort(array $array) { buildMaxHeap($array); $length = count($array); for ($i = $length - 1; $i \u0026gt; 0; $i--) { swap($array[0], $array[$i]); maxHeapify($array, 0, $i); } return $array; } /** * 有 child 的節點進行 heapify * (因為堆排不考慮 leaf 節點之間的大小) */ function buildMaxHeap(array \u0026amp;$array) { $length = count($array); for ($i = $length / 2; $i \u0026gt;= 0; $i--) { maxHeapify($array, $i, $length); } } /** * 由上而下檢查 subtree，使 subtree 滿足 max heap 規則 * @param array $array 紀錄 heap * @param integer $root 當前 subtree 的根節點 index * @param integer $length 要處理的陣列長度，也是判斷child是否超出陣列長度 */ function maxHeapify(array \u0026amp;$array, int $root, int $length) { $left = 2 * $root + 1; $right = $left + 1; $largest = $root; // 紀錄「根、左、右」，最大值節點 index  if ($left \u0026lt; $length \u0026amp;\u0026amp; $array[$left] \u0026gt; $array[$root]) $largest = $left; if ($right \u0026lt; $length \u0026amp;\u0026amp; $array[$right] \u0026gt; $array[$largest]) $largest = $right; if ($root !","title":"Heapsort"},{"content":" 又稱費波那契數列、斐氏數列、黃金分割數列。\n從 0 和 1 開始，之後的每個數字都是前兩個數字相加的結果\n例如：0, 1, 1, 2, 3, 5, 8, 13, 21...\n $$ F_n = F_{n-1} + F_{n-2} \\quad (n \\geq 2) $$\n求第 n 項費波那契數 遞迴 (Recursion) 1 2 3 4 5  function fib($n) { if ($n \u0026lt;= 1) return $n; return fib($n - 1) + fib($n - 2); }      Time complexity Space complexity     O(n2) O(n)    迭代 (Iteration) 1 2 3 4 5 6 7 8 9 10 11 12  function fib($n) { if ($n == 0) return 0; $p1 = 0; $p2 = 1; for ($i = 2; $i \u0026lt;= $n; $i++) { $tmp = $p1 + $p2; $p1 = $p2; $p2 = $tmp; } return $p2; }      Time complexity Space complexity     O(n) O(1)    動態規劃 (Dynamic programming) 1 2 3 4 5 6 7 8 9 10  function fib($n) { $result = []; $result[0] = 0; $result[1] = 1; for ($i = 2; $i \u0026lt;= $n; $i++) { $result[$i] = $result[$i - 1] + $result[$i - 2]; } return $result[$n]; }      Time complexity Space complexity     O(n) O(n)    黃金比例公式 $$ \\varphi = \\frac{1+\\sqrt5}{2} \\approx 1.618\u0026hellip; $$\n$$ F_n = \\frac{\\varphi^n}{\\sqrt5} - \\frac{(1-\\varphi)^2}{\\sqrt5} $$\n1 2 3 4 5  function fib($n) { $phi = (1 + sqrt(5)) / 2; return pow($phi, $n) / sqrt(5) - pow(1 - $phi, $n) / sqrt(5); }      Time complexity Space complexity     O(1) O(1)    Reference  費波那契數 wikipedia 黃金分割率 wikipedia Mathematics in R Markdown  ","permalink":"https://benny-sun.github.io/post/2020/fibonacci-sequence/","summary":"又稱費波那契數列、斐氏數列、黃金分割數列。\n從 0 和 1 開始，之後的每個數字都是前兩個數字相加的結果\n例如：0, 1, 1, 2, 3, 5, 8, 13, 21...\n $$ F_n = F_{n-1} + F_{n-2} \\quad (n \\geq 2) $$\n求第 n 項費波那契數 遞迴 (Recursion) 1 2 3 4 5  function fib($n) { if ($n \u0026lt;= 1) return $n; return fib($n - 1) + fib($n - 2); }      Time complexity Space complexity     O(n2) O(n)    迭代 (Iteration) 1 2 3 4 5 6 7 8 9 10 11 12  function fib($n) { if ($n == 0) return 0; $p1 = 0; $p2 = 1; for ($i = 2; $i \u0026lt;= $n; $i++) { $tmp = $p1 + $p2; $p1 = $p2; $p2 = $tmp; } return $p2; }      Time complexity Space complexity     O(n) O(1)    動態規劃 (Dynamic programming) 1 2 3 4 5 6 7 8 9 10  function fib($n) { $result = []; $result[0] = 0; $result[1] = 1; for ($i = 2; $i \u0026lt;= $n; $i++) { $result[$i] = $result[$i - 1] + $result[$i - 2]; } return $result[$n]; }      Time complexity Space complexity     O(n) O(n)    黃金比例公式 $$ \\varphi = \\frac{1+\\sqrt5}{2} \\approx 1.","title":"Fibonacci Sequence"},{"content":" 快速排序，屬於不穩定排序。\n運用分而治之的方式 (Divide and Conquer) 來優化排序效率。\n Divide \u0026amp; Conquer Divide 從數列裡挑任意一元素當作基準點(pivot) 將數列分成兩邊，一邊是大於 pivot，另一邊是小於 pivot； 這個行為稱作 Partition，Partition 執行完成後將 pivot 回傳，這也會當作後續 Partition 的起點和終點。\nConquer 將 Partition 的結果分別排序，效果就像下面圖片呈現的那樣(紅色是 pivot)：\nTime \u0026amp; Space complexity    Case Time complexity Space complexity     Best O(nlogn) O(1)   Average O(nlogn) O(1)   Worst O(n2) O(1)    實作 方法一 取數列的最後一個元素當作pivot(不一定要最後，可任意選)，由左至右掃描數列\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49  /** * 主程式 * 定義數列的排序範圍 */ function main(array $nums) { $front = 0; $end = count($nums) - 1; quickSort($nums, $front, $end); return $nums; } /** * Divide and Conquer * 遞迴將數列分為兩堆 */ function quickSort(array \u0026amp;$nums, int $front, int $end) { if ($front \u0026lt; $end) { $pivot = partition($nums, $front, $end); // Divide  quickSort($nums, $front, $pivot - 1); // Conquer  quickSort($nums, $pivot + 1, $end); } } /** * 比 pivot 大的放一堆，比 pivot 小的放一堆 * $i 表示「pivot 左邊數列最後一位」的 index * $j 走訪每個元素並跟 pivot 比大小 * index $i, $j 都由左至右移動 */ function partition(array \u0026amp;$nums, $front, $end) { $i = $front - 1; for ($j = $front; $j \u0026lt; $end; $j++) { if ($nums[$j] \u0026lt; $nums[$end]) { // 若當前元素大於pivot  $i++; // 則 index $i 往前走一步  swap($nums[$i], $nums[$j]); // 並與該元素交換  } } $i++; swap($nums[$i], $nums[$end]); // 把 pivot 移到數列中間(形成左小右大)  return $i; } function swap(\u0026amp;$a, \u0026amp;$b) { $tmp = $a; $a = $b; $b = $tmp; }   方法二 修改 partition()，選擇數列中間的數當作pivot(不一定要中間，可任意選)，由頭尾兩端向數列中間掃描\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  /** * 兩個 pointer $front, $end 分別從數列頭尾相向出發，並跟 pivot 比較 * 符合條件時 $front, $end 兩兩交換值 */ function partition(array \u0026amp;$nums, int $front, int $end) { $pivot = $nums[($front + $end) / 2]; while ($front \u0026lt; $end) { while ($nums[$front] \u0026lt; $pivot) $front++; while ($nums[$end] \u0026gt; $pivot) $end--; if ($front \u0026lt; $end) swap($nums[$front], $nums[$end]); } return $end; }   Reference  示意圖 演算法筆記  ","permalink":"https://benny-sun.github.io/post/2020/quicksort/","summary":"快速排序，屬於不穩定排序。\n運用分而治之的方式 (Divide and Conquer) 來優化排序效率。\n Divide \u0026amp; Conquer Divide 從數列裡挑任意一元素當作基準點(pivot) 將數列分成兩邊，一邊是大於 pivot，另一邊是小於 pivot； 這個行為稱作 Partition，Partition 執行完成後將 pivot 回傳，這也會當作後續 Partition 的起點和終點。\nConquer 將 Partition 的結果分別排序，效果就像下面圖片呈現的那樣(紅色是 pivot)：\nTime \u0026amp; Space complexity    Case Time complexity Space complexity     Best O(nlogn) O(1)   Average O(nlogn) O(1)   Worst O(n2) O(1)    實作 方法一 取數列的最後一個元素當作pivot(不一定要最後，可任意選)，由左至右掃描數列\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49  /** * 主程式 * 定義數列的排序範圍 */ function main(array $nums) { $front = 0; $end = count($nums) - 1; quickSort($nums, $front, $end); return $nums; } /** * Divide and Conquer * 遞迴將數列分為兩堆 */ function quickSort(array \u0026amp;$nums, int $front, int $end) { if ($front \u0026lt; $end) { $pivot = partition($nums, $front, $end); // Divide  quickSort($nums, $front, $pivot - 1); // Conquer  quickSort($nums, $pivot + 1, $end); } } /** * 比 pivot 大的放一堆，比 pivot 小的放一堆 * $i 表示「pivot 左邊數列最後一位」的 index * $j 走訪每個元素並跟 pivot 比大小 * index $i, $j 都由左至右移動 */ function partition(array \u0026amp;$nums, $front, $end) { $i = $front - 1; for ($j = $front; $j \u0026lt; $end; $j++) { if ($nums[$j] \u0026lt; $nums[$end]) { // 若當前元素大於pivot  $i++; // 則 index $i 往前走一步  swap($nums[$i], $nums[$j]); // 並與該元素交換  } } $i++; swap($nums[$i], $nums[$end]); // 把 pivot 移到數列中間(形成左小右大)  return $i; } function swap(\u0026amp;$a, \u0026amp;$b) { $tmp = $a; $a = $b; $b = $tmp; }   方法二 修改 partition()，選擇數列中間的數當作pivot(不一定要中間，可任意選)，由頭尾兩端向數列中間掃描","title":"Quicksort"},{"content":" 選擇排序，屬於不穩定排序。\n由左到右遍歷整個數列，找到最大(或小)元素，與當前的元素交換。\n Time \u0026amp; Space complexity    Case Time complexity Space complexity     Best O(n2) O(1)   Average O(n2) O(1)   Worst O(n2) O(1)     實作 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  function selectionSort(array $nums) { $len = count($nums); for ($i = 0; $i \u0026lt; $len; $i++) { $max = $i; for ($j = $i + 1; $j \u0026lt; $len; $j++) { // 找出最大值的 index  if ($nums[$j] \u0026gt; $nums[$max]) $max = $j; } if ($nums[$max] \u0026gt; $nums[$i])\t// 最大值如果大於當前的元素  swap($nums[$max], $nums[$i]);\t// 就兩兩交換  } return $nums; } function swap(\u0026amp;$a, \u0026amp;$b) { $tmp = $a; $a = $b; $b = $tmp; }    補充說明 關於不穩定排序，如果數列中出現元素的數值相同的情況，經過排序後，這些同元素的相對位置可能會與排序前不同。\n例如：數列 3,2,3,1，由小到大排序結果為 1, 2, 3, 3\n這個結果看起來是沒錯的，但如果排序要求更嚴格的話，就不適合使用此排序法\n為什麼呢？\n以上述例子，將重複元素 3 作記號，排序前是這樣\n3', 2, 3, 1\n由小到大排序完畢後，期望得到的結果是這樣\n1, 2, 3', 3\n但使用選擇排序的話，實際結果卻是\n1, 2, 3, 3'\n3' 和 3 的相對位置在排序後改變了，因此稱作不穩定排序。\n","permalink":"https://benny-sun.github.io/post/2020/selection-sort/","summary":"選擇排序，屬於不穩定排序。\n由左到右遍歷整個數列，找到最大(或小)元素，與當前的元素交換。\n Time \u0026amp; Space complexity    Case Time complexity Space complexity     Best O(n2) O(1)   Average O(n2) O(1)   Worst O(n2) O(1)     實作 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  function selectionSort(array $nums) { $len = count($nums); for ($i = 0; $i \u0026lt; $len; $i++) { $max = $i; for ($j = $i + 1; $j \u0026lt; $len; $j++) { // 找出最大值的 index  if ($nums[$j] \u0026gt; $nums[$max]) $max = $j; } if ($nums[$max] \u0026gt; $nums[$i])\t// 最大值如果大於當前的元素  swap($nums[$max], $nums[$i]);\t// 就兩兩交換  } return $nums; } function swap(\u0026amp;$a, \u0026amp;$b) { $tmp = $a; $a = $b; $b = $tmp; }    補充說明 關於不穩定排序，如果數列中出現元素的數值相同的情況，經過排序後，這些同元素的相對位置可能會與排序前不同。","title":"Selection Sort"},{"content":" 又叫插入排序，屬於穩定排序。\n像是玩撲克牌整理牌組，將未排序的牌堆插入已排序的牌堆那樣，如果在大部分的元素已是有序的話使用此排序法效率較好。\n Time \u0026amp; Space complexity    Case Time complexity Space complexity     Best O(n) O(1)   Average O(n2) O(1)   Worst O(n2) O(1)    實作 1 2 3 4 5 6 7 8 9 10 11  function insertionSort(array $nums) { $len = count($nums); for ($i = 1; $i \u0026lt; $len; $i++) { $temp = $nums[$i]; for ($j = $i; $j \u0026gt; 0 \u0026amp;\u0026amp; $nums[$j - 1] \u0026gt; $temp; $j--) { $nums[$j] = $nums[$j - 1]; } $nums[$j] = $temp; } return $nums; }   ","permalink":"https://benny-sun.github.io/post/2020/insertion-sort/","summary":" 又叫插入排序，屬於穩定排序。\n像是玩撲克牌整理牌組，將未排序的牌堆插入已排序的牌堆那樣，如果在大部分的元素已是有序的話使用此排序法效率較好。\n Time \u0026amp; Space complexity    Case Time complexity Space complexity     Best O(n) O(1)   Average O(n2) O(1)   Worst O(n2) O(1)    實作 1 2 3 4 5 6 7 8 9 10 11  function insertionSort(array $nums) { $len = count($nums); for ($i = 1; $i \u0026lt; $len; $i++) { $temp = $nums[$i]; for ($j = $i; $j \u0026gt; 0 \u0026amp;\u0026amp; $nums[$j - 1] \u0026gt; $temp; $j--) { $nums[$j] = $nums[$j - 1]; } $nums[$j] = $temp; } return $nums; }   ","title":"Insertion Sort"},{"content":" 又叫氣泡排序、泡沫排序，屬於穩定排序。\n由左到右遍歷，當前元素與下一個元素比較，符合條件則兩兩將交換，依次推向數列的右端，就好像冒泡泡一樣，將排序結果一個一個浮上來。\n Time \u0026amp; Space complexity    Case Time complexity Space complexity     Best O(n) O(1)   Average O(n2) O(1)   Worst O(n2) O(1)    實作 普通版 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  function bubbleSort(array $nums) { $len = count($nums); for ($i = 0; $i \u0026lt; $len; $i++) { for ($j = 0; $j \u0026lt; $len - $i - 1; $j++) { if ($nums[$j] \u0026lt; $nums[$j + 1]) swap($nums[$j], $nums[$j + 1]); } } return $nums; } function swap(\u0026amp;$a, \u0026amp;$b) { $tmp = $a; $a = $b; $b = $tmp; }   優化版 用一個變數去紀錄數列的狀態，如果內層迴圈迭代完，數字都沒有交換，表示數列已經是有序的，就中止迴圈:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  function bubbleSort(array $nums) { $len = count($nums); for ($i = 0; $i \u0026lt; $len; $i++) { $isSorted = true; for ($j = 0; $j \u0026lt; $len - $i - 1; $j++) { if ($nums[$j] \u0026lt; $nums[$j + 1]) { swap($nums[$j], $nums[$j + 1]); $isSorted = false; } } if ($isSorted) break; } return $nums; } function swap(\u0026amp;$a, \u0026amp;$b) { $tmp = $a; $a = $b; $b = $tmp; }   ","permalink":"https://benny-sun.github.io/post/2020/bubble-sort/","summary":"又叫氣泡排序、泡沫排序，屬於穩定排序。\n由左到右遍歷，當前元素與下一個元素比較，符合條件則兩兩將交換，依次推向數列的右端，就好像冒泡泡一樣，將排序結果一個一個浮上來。\n Time \u0026amp; Space complexity    Case Time complexity Space complexity     Best O(n) O(1)   Average O(n2) O(1)   Worst O(n2) O(1)    實作 普通版 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  function bubbleSort(array $nums) { $len = count($nums); for ($i = 0; $i \u0026lt; $len; $i++) { for ($j = 0; $j \u0026lt; $len - $i - 1; $j++) { if ($nums[$j] \u0026lt; $nums[$j + 1]) swap($nums[$j], $nums[$j + 1]); } } return $nums; } function swap(\u0026amp;$a, \u0026amp;$b) { $tmp = $a; $a = $b; $b = $tmp; }   優化版 用一個變數去紀錄數列的狀態，如果內層迴圈迭代完，數字都沒有交換，表示數列已經是有序的，就中止迴圈:","title":"Bubble Sort"}]