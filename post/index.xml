<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Posts on 班尼の筆記</title>
    <link>https://benny-sun.github.io/post/</link>
    <description>Recent content in Posts on 班尼の筆記</description>
    <image>
      <url>https://benny-sun.github.io/papermod-cover.png</url>
      <link>https://benny-sun.github.io/papermod-cover.png</link>
    </image>
    <generator>Hugo -- gohugo.io</generator>
    <lastBuildDate>Sun, 12 Jun 2022 13:28:28 +0800</lastBuildDate><atom:link href="https://benny-sun.github.io/post/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Strategy pattern</title>
      <link>https://benny-sun.github.io/post/design-pattern/strategy/</link>
      <pubDate>Sun, 12 Jun 2022 13:28:28 +0800</pubDate>
      
      <guid>https://benny-sun.github.io/post/design-pattern/strategy/</guid>
      <description>概念 像是選擇不同交通方式上班， 把影響選擇的因素(例如: 天候、預算、身體狀況、緊急程度等)和選擇帶來的後果(例如: 路線、耗時、花費等)拆分開來管理。
圖片來源: https://refactoring.guru/design-patterns/strategy  這篇來自讀過 Design Patterns Explained: A New Perspective on Object Oriented Design, 2nd Edition 一書中 The Strategy Pattern 章節的重點整理。
作者提出一系列面對新需求的應對方式使系統程式碼更具彈性，在面對未來的變化能更從容、更易擴充和維護。
 處理新需求之案例研究 書中以一個在美國的國際電商為實務案例來說明在面對新需求的思考和處理方式。
訂單處理系統之系統架構 TaskController
 處理銷售請求 決定何時將請求交給 SalesOrder 來處理訂單  SalesOrder
 透過 GUI 填寫訂單 處理稅額計算 &amp;lt;&amp;ndash; 本章討論案例 列印收據    新需求：支援加拿大的稅額計算
 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23  // Handle Tax switch (myNation) { case US: // US Tax rules here break;  case Canada: // Canadian Tax rules here break; } // Handle Currency switch (myNation) { case US: // US Currency rules here break;  case Canada: // Canadian Currency rules here break; } // Handle Date Format switch (myNation) { case US: // use mm/dd/yy format break;  case Canada: // use dd/mm/yy format break; }     新需求：支援德國的稅額計算＆多國語系</description>
    </item>
    
    <item>
      <title>Merge Sort</title>
      <link>https://benny-sun.github.io/post/2020/merge-sort/</link>
      <pubDate>Sun, 29 Mar 2020 17:33:15 +0800</pubDate>
      
      <guid>https://benny-sun.github.io/post/2020/merge-sort/</guid>
      <description> 合併排序，屬於穩定排序。
把數列從中間拆分成兩段，直到不能再分，將拆分的元素兩兩比對後再合併起來，達到排序效果。
 Time &amp;amp; Space complexity    Case Time complexity Space complexity     Best O(nlogn) O(1)   Average O(nlogn) O(1)   Worst O(nlogn) O(1)    實作 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49  /** * 主程式 * 定義數列要排序的開頭及結尾 */ function mergeSort(array $nums) { $front = 0; $end = count($nums) - 1; MSort($nums, $front, $end); return $nums; } /** * 遞迴將數列兩半拆分 */ function MSort(array &amp;amp;$nums, $front, $end) { if ($front &amp;lt; $end) { $mid = intval(($front + $end) / 2); MSort($nums, $front, $mid); // 拆分左半邊的數列  MSort($nums, $mid + 1, $end); // 拆分右半邊的數列  merge($nums, $front, $mid, $end); } } /** * 將左右兩邊的數列比大小後再合併 */ function merge(array &amp;amp;$nums, $front, $mid, $end) { $len = ($end - $front) / 2 + 1; $leftNums = array_slice($nums, $front, $len); $rightNums = array_slice($nums, $mid + 1, $len); $left[] = PHP_INT_MAX; $right[] = PHP_INT_MAX; $idxLeft = 0; $idxRight = 0; for ($i = $front; $i &amp;lt;= $end; $i++) { if ($leftNums[$idxLeft] &amp;lt; $rightNums[$idxRight]) { $nums[$i] = $leftNums[$idxLeft]; $idxLeft++; } else { $nums[$i] = $rightNums[$idxRight]; $idxRight++; } } }   Reference  示意圖  </description>
    </item>
    
    <item>
      <title>Heapsort</title>
      <link>https://benny-sun.github.io/post/2020/heapsort/</link>
      <pubDate>Sun, 29 Mar 2020 10:30:16 +0800</pubDate>
      
      <guid>https://benny-sun.github.io/post/2020/heapsort/</guid>
      <description>又叫堆積排序，屬於穩定排序。 把陣列作為 binary tree 的資料結構，逐一把元素加入 heap 達到排序效果。
 Time &amp;amp; Space complexity    Case Time complexity Space complexity     Best O(nlogn) O(1)   Average O(nlogn) O(1)   Worst O(nlogn) O(1)    實作 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56  /** * 主函式 * 將數列由小到大排序 */ function heapSort(array $array) { buildMaxHeap($array); $length = count($array); for ($i = $length - 1; $i &amp;gt; 0; $i--) { swap($array[0], $array[$i]); maxHeapify($array, 0, $i); } return $array; } /** * 有 child 的節點進行 heapify * (因為堆排不考慮 leaf 節點之間的大小) */ function buildMaxHeap(array &amp;amp;$array) { $length = count($array); for ($i = $length / 2; $i &amp;gt;= 0; $i--) { maxHeapify($array, $i, $length); } } /** * 由上而下檢查 subtree，使 subtree 滿足 max heap 規則 * @param array $array 紀錄 heap * @param integer $root 當前 subtree 的根節點 index * @param integer $length 要處理的陣列長度，也是判斷child是否超出陣列長度 */ function maxHeapify(array &amp;amp;$array, int $root, int $length) { $left = 2 * $root + 1; $right = $left + 1; $largest = $root; // 紀錄「根、左、右」，最大值節點 index  if ($left &amp;lt; $length &amp;amp;&amp;amp; $array[$left] &amp;gt; $array[$root]) $largest = $left; if ($right &amp;lt; $length &amp;amp;&amp;amp; $array[$right] &amp;gt; $array[$largest]) $largest = $right; if ($root !</description>
    </item>
    
    <item>
      <title>Fibonacci Sequence</title>
      <link>https://benny-sun.github.io/post/2020/fibonacci-sequence/</link>
      <pubDate>Fri, 06 Mar 2020 22:25:05 +0800</pubDate>
      
      <guid>https://benny-sun.github.io/post/2020/fibonacci-sequence/</guid>
      <description>又稱費波那契數列、斐氏數列、黃金分割數列。
從 0 和 1 開始，之後的每個數字都是前兩個數字相加的結果
例如：0, 1, 1, 2, 3, 5, 8, 13, 21...
 $$ F_n = F_{n-1} + F_{n-2} \quad (n \geq 2) $$
求第 n 項費波那契數 遞迴 (Recursion) 1 2 3 4 5  function fib($n) { if ($n &amp;lt;= 1) return $n; return fib($n - 1) + fib($n - 2); }      Time complexity Space complexity     O(n2) O(n)    迭代 (Iteration) 1 2 3 4 5 6 7 8 9 10 11 12  function fib($n) { if ($n == 0) return 0; $p1 = 0; $p2 = 1; for ($i = 2; $i &amp;lt;= $n; $i++) { $tmp = $p1 + $p2; $p1 = $p2; $p2 = $tmp; } return $p2; }      Time complexity Space complexity     O(n) O(1)    動態規劃 (Dynamic programming) 1 2 3 4 5 6 7 8 9 10  function fib($n) { $result = []; $result[0] = 0; $result[1] = 1; for ($i = 2; $i &amp;lt;= $n; $i++) { $result[$i] = $result[$i - 1] + $result[$i - 2]; } return $result[$n]; }      Time complexity Space complexity     O(n) O(n)    黃金比例公式 $$ \varphi = \frac{1+\sqrt5}{2} \approx 1.</description>
    </item>
    
    <item>
      <title>Quicksort</title>
      <link>https://benny-sun.github.io/post/2020/quicksort/</link>
      <pubDate>Thu, 05 Mar 2020 23:46:25 +0800</pubDate>
      
      <guid>https://benny-sun.github.io/post/2020/quicksort/</guid>
      <description>快速排序，屬於不穩定排序。
運用分而治之的方式 (Divide and Conquer) 來優化排序效率。
 Divide &amp;amp; Conquer Divide 從數列裡挑任意一元素當作基準點(pivot) 將數列分成兩邊，一邊是大於 pivot，另一邊是小於 pivot； 這個行為稱作 Partition，Partition 執行完成後將 pivot 回傳，這也會當作後續 Partition 的起點和終點。
Conquer 將 Partition 的結果分別排序，效果就像下面圖片呈現的那樣(紅色是 pivot)：
Time &amp;amp; Space complexity    Case Time complexity Space complexity     Best O(nlogn) O(1)   Average O(nlogn) O(1)   Worst O(n2) O(1)    實作 方法一 取數列的最後一個元素當作pivot(不一定要最後，可任意選)，由左至右掃描數列
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49  /** * 主程式 * 定義數列的排序範圍 */ function main(array $nums) { $front = 0; $end = count($nums) - 1; quickSort($nums, $front, $end); return $nums; } /** * Divide and Conquer * 遞迴將數列分為兩堆 */ function quickSort(array &amp;amp;$nums, int $front, int $end) { if ($front &amp;lt; $end) { $pivot = partition($nums, $front, $end); // Divide  quickSort($nums, $front, $pivot - 1); // Conquer  quickSort($nums, $pivot + 1, $end); } } /** * 比 pivot 大的放一堆，比 pivot 小的放一堆 * $i 表示「pivot 左邊數列最後一位」的 index * $j 走訪每個元素並跟 pivot 比大小 * index $i, $j 都由左至右移動 */ function partition(array &amp;amp;$nums, $front, $end) { $i = $front - 1; for ($j = $front; $j &amp;lt; $end; $j++) { if ($nums[$j] &amp;lt; $nums[$end]) { // 若當前元素大於pivot  $i++; // 則 index $i 往前走一步  swap($nums[$i], $nums[$j]); // 並與該元素交換  } } $i++; swap($nums[$i], $nums[$end]); // 把 pivot 移到數列中間(形成左小右大)  return $i; } function swap(&amp;amp;$a, &amp;amp;$b) { $tmp = $a; $a = $b; $b = $tmp; }   方法二 修改 partition()，選擇數列中間的數當作pivot(不一定要中間，可任意選)，由頭尾兩端向數列中間掃描</description>
    </item>
    
    <item>
      <title>Selection Sort</title>
      <link>https://benny-sun.github.io/post/2020/selection-sort/</link>
      <pubDate>Wed, 04 Mar 2020 23:10:55 +0800</pubDate>
      
      <guid>https://benny-sun.github.io/post/2020/selection-sort/</guid>
      <description>選擇排序，屬於不穩定排序。
由左到右遍歷整個數列，找到最大(或小)元素，與當前的元素交換。
 Time &amp;amp; Space complexity    Case Time complexity Space complexity     Best O(n2) O(1)   Average O(n2) O(1)   Worst O(n2) O(1)     實作 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  function selectionSort(array $nums) { $len = count($nums); for ($i = 0; $i &amp;lt; $len; $i++) { $max = $i; for ($j = $i + 1; $j &amp;lt; $len; $j++) { // 找出最大值的 index  if ($nums[$j] &amp;gt; $nums[$max]) $max = $j; } if ($nums[$max] &amp;gt; $nums[$i])	// 最大值如果大於當前的元素  swap($nums[$max], $nums[$i]);	// 就兩兩交換  } return $nums; } function swap(&amp;amp;$a, &amp;amp;$b) { $tmp = $a; $a = $b; $b = $tmp; }    補充說明 關於不穩定排序，如果數列中出現元素的數值相同的情況，經過排序後，這些同元素的相對位置可能會與排序前不同。</description>
    </item>
    
    <item>
      <title>Insertion Sort</title>
      <link>https://benny-sun.github.io/post/2020/insertion-sort/</link>
      <pubDate>Wed, 04 Mar 2020 22:59:24 +0800</pubDate>
      
      <guid>https://benny-sun.github.io/post/2020/insertion-sort/</guid>
      <description> 又叫插入排序，屬於穩定排序。
像是玩撲克牌整理牌組，將未排序的牌堆插入已排序的牌堆那樣，如果在大部分的元素已是有序的話使用此排序法效率較好。
 Time &amp;amp; Space complexity    Case Time complexity Space complexity     Best O(n) O(1)   Average O(n2) O(1)   Worst O(n2) O(1)    實作 1 2 3 4 5 6 7 8 9 10 11  function insertionSort(array $nums) { $len = count($nums); for ($i = 1; $i &amp;lt; $len; $i++) { $temp = $nums[$i]; for ($j = $i; $j &amp;gt; 0 &amp;amp;&amp;amp; $nums[$j - 1] &amp;gt; $temp; $j--) { $nums[$j] = $nums[$j - 1]; } $nums[$j] = $temp; } return $nums; }   </description>
    </item>
    
    <item>
      <title>Bubble Sort</title>
      <link>https://benny-sun.github.io/post/2020/bubble-sort/</link>
      <pubDate>Wed, 04 Mar 2020 22:25:23 +0800</pubDate>
      
      <guid>https://benny-sun.github.io/post/2020/bubble-sort/</guid>
      <description>又叫氣泡排序、泡沫排序，屬於穩定排序。
由左到右遍歷，當前元素與下一個元素比較，符合條件則兩兩將交換，依次推向數列的右端，就好像冒泡泡一樣，將排序結果一個一個浮上來。
 Time &amp;amp; Space complexity    Case Time complexity Space complexity     Best O(n) O(1)   Average O(n2) O(1)   Worst O(n2) O(1)    實作 普通版 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  function bubbleSort(array $nums) { $len = count($nums); for ($i = 0; $i &amp;lt; $len; $i++) { for ($j = 0; $j &amp;lt; $len - $i - 1; $j++) { if ($nums[$j] &amp;lt; $nums[$j + 1]) swap($nums[$j], $nums[$j + 1]); } } return $nums; } function swap(&amp;amp;$a, &amp;amp;$b) { $tmp = $a; $a = $b; $b = $tmp; }   優化版 用一個變數去紀錄數列的狀態，如果內層迴圈迭代完，數字都沒有交換，表示數列已經是有序的，就中止迴圈:</description>
    </item>
    
  </channel>
</rss>
